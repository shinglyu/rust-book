<!DOCTYPE HTML>
<html lang="zh-Hant">
    <head>
        <meta charset="UTF-8">
        <title>Rust ç¨‹å¼èªè¨€ æ­£é«”ä¸­æ–‡ç‰ˆ</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Rust Programming Language">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

		<style>
            @import url(http://fonts.googleapis.com/earlyaccess/cwtexhei.css);
        </style>
        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> ç°¡ä»‹</a></li><li><a href="getting-started.html"><strong>2.</strong> æº–å‚™</a></li><li><a href="guessing-game.html"><strong>3.</strong> æ•™å­¸: çŒœæ•¸å­—éŠæˆ²</a></li><li><a href="syntax-and-semantics.html"><strong>4.</strong> èªæ³•åŠèªæ„</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>4.1.</strong> è®Šæ•¸ç¶å®š</a></li><li><a href="functions.html"><strong>4.2.</strong> å‡½å¼</a></li><li><a href="primitive-types.html"><strong>4.3.</strong> åŸºæœ¬å‹åˆ¥</a></li><li><a href="comments.html"><strong>4.4.</strong> è¨»è§£</a></li><li><a href="if.html"><strong>4.5.</strong> if</a></li><li><a href="loops.html"><strong>4.6.</strong> è¿´åœˆ</a></li><li><a href="ownership.html"><strong>4.7.</strong> æ‰€æœ‰æ¬Š</a></li><li><a href="references-and-borrowing.html"><strong>4.8.</strong> åƒç…§èˆ‡å€Ÿç”¨</a></li><li><a href="lifetimes.html"><strong>4.9.</strong> ç”Ÿå‘½é€±æœŸ</a></li><li><a href="mutability.html"><strong>4.10.</strong> å¯è®Šæ€§</a></li><li><a href="structs.html"><strong>4.11.</strong> çµæ§‹é«”</a></li><li><a href="enums.html"><strong>4.12.</strong> æšèˆ‰</a></li><li><a href="match.html"><strong>4.13.</strong> Match</a></li><li><a href="patterns.html" class="active"><strong>4.14.</strong> æ¨¡å¼</a></li><li><a href="method-syntax.html"><strong>4.15.</strong> Method Syntax</a></li><li><a href="vectors.html"><strong>4.16.</strong> Vectors</a></li><li><a href="strings.html"><strong>4.17.</strong> Strings</a></li><li><a href="generics.html"><strong>4.18.</strong> Generics</a></li><li><a href="traits.html"><strong>4.19.</strong> Traits</a></li><li><a href="drop.html"><strong>4.20.</strong> Drop</a></li><li><a href="if-let.html"><strong>4.21.</strong> if let</a></li><li><a href="trait-objects.html"><strong>4.22.</strong> Trait Objects</a></li><li><a href="closures.html"><strong>4.23.</strong> Closures</a></li><li><a href="ufcs.html"><strong>4.24.</strong> Universal Function Call Syntax</a></li><li><a href="crates-and-modules.html"><strong>4.25.</strong> Crates and Modules</a></li><li><a href="const-and-static.html"><strong>4.26.</strong> <code>const</code> and <code>static</code></a></li><li><a href="attributes.html"><strong>4.27.</strong> Attributes</a></li><li><a href="type-aliases.html"><strong>4.28.</strong> <code>type</code> aliases</a></li><li><a href="casting-between-types.html"><strong>4.29.</strong> Casting between types</a></li><li><a href="associated-types.html"><strong>4.30.</strong> Associated Types</a></li><li><a href="unsized-types.html"><strong>4.31.</strong> Unsized Types</a></li><li><a href="operators-and-overloading.html"><strong>4.32.</strong> Operators and Overloading</a></li><li><a href="deref-coercions.html"><strong>4.33.</strong> Deref coercions</a></li><li><a href="macros.html"><strong>4.34.</strong> Macros</a></li><li><a href="raw-pointers.html"><strong>4.35.</strong> Raw Pointers</a></li><li><a href="unsafe.html"><strong>4.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="effective-rust.html"><strong>5.</strong> Effective Rust</a></li><li><ul class="section"><li><a href="the-stack-and-the-heap.html"><strong>5.1.</strong> The Stack and the Heap</a></li><li><a href="testing.html"><strong>5.2.</strong> Testing</a></li><li><a href="conditional-compilation.html"><strong>5.3.</strong> Conditional Compilation</a></li><li><a href="documentation.html"><strong>5.4.</strong> Documentation</a></li><li><a href="iterators.html"><strong>5.5.</strong> Iterators</a></li><li><a href="concurrency.html"><strong>5.6.</strong> Concurrency</a></li><li><a href="error-handling.html"><strong>5.7.</strong> Error Handling</a></li><li><a href="choosing-your-guarantees.html"><strong>5.8.</strong> Choosing your Guarantees</a></li><li><a href="ffi.html"><strong>5.9.</strong> FFI</a></li><li><a href="borrow-and-asref.html"><strong>5.10.</strong> Borrow and AsRef</a></li><li><a href="release-channels.html"><strong>5.11.</strong> Release Channels</a></li><li><a href="using-rust-without-the-standard-library.html"><strong>5.12.</strong> Using Rust without the standard library</a></li></ul></li><li><a href="nightly-rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="compiler-plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="inline-assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="no-stdlib.html"><strong>6.3.</strong> No stdlib</a></li><li><a href="intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="lang-items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="advanced-linking.html"><strong>6.6.</strong> Advanced linking</a></li><li><a href="benchmark-tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="box-syntax-and-patterns.html"><strong>6.8.</strong> Box Syntax and Patterns</a></li><li><a href="slice-patterns.html"><strong>6.9.</strong> Slice Patterns</a></li><li><a href="associated-constants.html"><strong>6.10.</strong> Associated Constants</a></li><li><a href="custom-allocators.html"><strong>6.11.</strong> Custom Allocators</a></li></ul></li><li><a href="glossary.html"><strong>7.</strong> è©å½™è¡¨</a></li><li><a href="syntax-index.html"><strong>8.</strong> èªæ³•ç´¢å¼•</a></li><li><a href="bibliography.html"><strong>9.</strong> åƒè€ƒæ–‡ç»</a></li><li><a href="MappingTable.html"><strong>10.</strong> ä¸­è‹±æ–‡å­—å½™å°ç…§è¡¨</a></li><li><a href="CONTRIBUTORS.html"><strong>11.</strong> ç¿»è­¯è²¢ç»åå–®</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Rust ç¨‹å¼èªè¨€ æ­£é«”ä¸­æ–‡ç‰ˆ</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>æ¨¡å¼</h1>
<p>æ¨¡å¼ (pattern) åœ¨ Rust ä¸­å¾ˆå¸¸è¦‹ã€‚
æˆ‘å€‘åœ¨<a href="variable-bindings.html">è®Šæ•¸ç¶å®š</a>ã€<a href="match.html">match é™³è¿°å¼</a>ã€åŠå…¶ä»–åœ°æ–¹éƒ½æœƒç”¨åˆ°ã€‚
è®“æˆ‘å€‘é–‹å§‹å¿«é€Ÿåœ°äº†è§£æ¨¡å¼å¯ä»¥åšåˆ°äº›ä»€éº¼ï¼</p>
<p>å¿«é€Ÿè¤‡ç¿’ä¸€ä¸‹ï¼šä½ å¯ä»¥ç›´æ¥é…å°è®Šæ•¸ï¼Œè€Œ <code>_</code> å°‡æœƒé…å°åˆ° &quot;ä»»ä½•&quot; æ²’åˆ—å‡ºä¾†çš„å…¶ä»–æƒ…æ³ï¼š</p>
<pre><code class="language-rust">let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
</code></pre>
<p>é€™æœƒå°å‡º <code>one</code>ã€‚</p>
<p>æ¨¡å¼æœ‰å€‹é™·é˜±ï¼šå®ƒæœƒç”¢ç”Ÿé®è”½ (shadowing)ï¼Œèˆ‡å…¶ä»–æœƒç”¢ç”Ÿæ–°çš„ç¶å®šçš„ä»»ä½•æ±è¥¿ä¸€æ¨£ã€‚
èˆ‰ä¾‹ä¾†èªªï¼š</p>
<pre><code class="language-rust">let x = 1;
let c = 'c';

match c {
    x =&gt; println!(&quot;x: {} c: {}&quot;, x, c),
}

println!(&quot;x: {}&quot;, x)
</code></pre>
<p>é€™æœƒå°å‡ºï¼š</p>
<pre><code class="language-text">x: c c: c
x: 1
</code></pre>
<p>æ›å¥è©±èªªï¼Œ<code>x =&gt;</code> ç¬¦åˆæ¨¡å¼ï¼Œè€Œä¸”ç”¢ç”Ÿäº†æ–°çš„åç‚º <code>x</code> çš„ç¶å®šã€‚
æ–°ç¶å®šçš„æœ‰æ•ˆç¯„åœåœ¨è©² match çš„åŸ·è¡Œåˆ†æ”¯ä¸­ï¼Œä¸”å®ƒçš„å€¼è¢«è³¦äºˆç‚º <code>c</code>ã€‚
è«‹æ³¨æ„ï¼Œåœ¨ match æœ‰æ•ˆç¯„åœä¹‹å¤–çš„ <code>x</code> çš„å€¼ä¸æœƒå½±éŸ¿åˆ°ç¯„åœå…§çš„ <code>x</code>ã€‚
å› ç‚ºæˆ‘å€‘æœ¬ä¾†å·²ç¶“æœ‰äº† <code>x</code> ç¶å®šï¼Œè€Œæ–°çš„ <code>x</code> é®è”½äº†å®ƒã€‚</p>
<h2>å¤šé‡æ¨¡å¼ (Multiple patterns)</h2>
<p>ä½ å¯ä»¥ä½¿ç”¨ <code>|</code> ä¾†é…å°å¤šé‡æ¨¡å¼ï¼š</p>
<pre><code class="language-rust">let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
</code></pre>
<p>é€™æœƒå°å‡º <code>one or two</code>ã€‚</p>
<h2>è§£æ§‹ (Destructuring)</h2>
<p>å¦‚æœä½ æœ‰å€‹è¤‡åˆçš„è³‡æ–™å‹åˆ¥ï¼Œåƒæ˜¯<a href="structs.html">çµæ§‹é«”</a> (struct)ï¼Œä½ å¯ä»¥åœ¨æ¨¡å¼ä¸­è§£æ§‹å®ƒï¼š</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, y } =&gt; println!(&quot;({},{})&quot;, x, y),
}
</code></pre>
<p>æˆ‘å€‘å¯ä»¥ä½¿ç”¨ <code>:</code> çµ¦äºˆå€¼æ–°çš„ä¸åŒå‘½åã€‚</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x: x1, y: y1 } =&gt; println!(&quot;({},{})&quot;, x1, y1),
}
</code></pre>
<p>å¦‚æœæˆ‘å€‘åªåœ¨æ„æŸäº›å€¼ï¼Œæˆ‘å€‘ä¸éœ€è¦çµ¦å®ƒæ‰€æœ‰åç¨±ï¼š</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
</code></pre>
<p>é€™æœƒå°å‡º <code>x is 0</code>ã€‚</p>
<p>ä½ å¯ä»¥å°ä»»ä½•æˆå“¡é€²è¡Œé€™æ¨£çš„é…å°ï¼Œè€Œä¸åƒ…é™æ–¼ç¬¬ä¸€å€‹ï¼š</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { y, .. } =&gt; println!(&quot;y is {}&quot;, y),
}
</code></pre>
<p>é€™æœƒå°å‡º <code>y is 0</code>ã€‚</p>
<p>é€™ç¨® &quot;è§£æ§‹&quot; è¡Œç‚ºåœ¨ä»»ä½•è¤‡åˆè³‡æ–™å‹åˆ¥ä¸Šéƒ½å¯ä»¥é‹ä½œï¼Œåƒ<a href="primitive-types.html#%E5%A4%9A%E5%85%83%E7%B5%84%20(Tuples)">å¤šå…ƒçµ„</a> (tuple) æˆ–<a href="enums.html">æšèˆ‰</a> (enum) éƒ½å¯ä»¥ã€‚</p>
<h2>å¿½ç•¥ç¶å®š</h2>
<p>ä½ å¯ä»¥åœ¨æ¨¡å¼ä¸­ä½¿ç”¨ <code>_</code> å¿½ç•¥å‹åˆ¥è·Ÿå€¼ã€‚
èˆ‰ä¾‹ä¾†èªªï¼Œé€™æ˜¯ä¸€å€‹ <code>Result&lt;T, E&gt;</code> çš„ <code>match</code> ä¾‹å­ï¼š</p>
<pre><code class="language-rust"># let some_value: Result&lt;i32, &amp;'static str&gt; = Err(&quot;There was an error&quot;);
match some_value {
    Ok(value) =&gt; println!(&quot;got a value: {}&quot;, value),
    Err(_) =&gt; println!(&quot;an error occurred&quot;),
}
</code></pre>
<p>åœ¨ç¬¬ä¸€å€‹åŸ·è¡Œåˆ†æ”¯ä¸­ï¼Œæˆ‘å€‘æŠŠ <code>OK</code> å…§çš„å€¼ç¶å®šåˆ° <code>value</code> ä¸Šã€‚
ä½†æ˜¯åœ¨ <code>Err</code> åˆ†æ”¯ï¼Œæˆ‘å€‘ä½¿ç”¨ <code>_</code> ä¾†å¿½ç•¥ç‰¹å®šçš„éŒ¯èª¤ï¼Œå°å‡ºé€šç”¨çš„éŒ¯èª¤è¨Šæ¯ã€‚</p>
<p><code>_</code> åœ¨ä»»ä½•å»ºç«‹ç¶å®šçš„æ¨¡å¼ä¸­éƒ½æœ‰æ•ˆã€‚
é€™åœ¨å¤§å‹çµæ§‹é«”ä¸­è¦å¿½ç•¥æŸäº›éƒ¨ä»½æ™‚ä¹Ÿéå¸¸æœ‰ç”¨ï¼š</p>
<pre><code class="language-rust">fn coordinate() -&gt; (i32, i32, i32) {
    // generate and return some sort of triple tuple
# (1, 2, 3)
}

let (x, _, z) = coordinate();
</code></pre>
<p>åœ¨é€™é‚Šï¼Œæˆ‘å€‘æŠŠå¤šå…ƒçµ„ä¸­çš„ç¬¬ä¸€å€‹è·Ÿæœ€å¾Œä¸€å€‹å…ƒç´ ç¶å®šåˆ° <code>x</code> è·Ÿ <code>z</code>ï¼Œä½†æ˜¯å¿½ç•¥äº†ä¸­é–“çš„å…ƒç´ ã€‚</p>
<p>å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œ<code>_</code> ä¸¦ä¸æœƒç¶å®šè®Šæ•¸ï¼Œé€™ä»£è¡¨å€¼ä¸æœƒç§»å‹•æ‰€æœ‰æ¬Šï¼š</p>
<blockquote>
<p>è­¯è¨»ï¼šä½†å¦‚æœçµ¦äº†è®Šæ•¸åç¨±ï¼Œæ²’æœ‰å¯¦ä½œ Copy çš„å…ƒç´ å°±æœƒæŠŠæ‰€æœ‰æ¬Šç§»åˆ°è©²è®Šæ•¸ä¸Šï¼Œå› æ­¤ä½¿ç”¨åŸä¾†çš„ç¶å®šæ™‚æœƒå‡ºç¾ <code>error: use of moved value</code> éŒ¯èª¤ã€‚
åœ¨ä»¥ä¸‹ä¾‹å­ä¸­ï¼Œ<code>tuple.0</code> å› ç‚ºæ˜¯ <code>u32</code> æœ‰å¯¦ä½œ Copy traitï¼Œæ‰€ä»¥ä»å¯ä»¥ä½¿ç”¨ï¼Œåªæœ‰ <code>tuple.1</code> æ˜¯ <code>String</code>ï¼Œå› ç‚ºçµ¦äº†å‘½åï¼Œæ‰€ä»¥æ‰€æœ‰æ¬Šè¢«è½‰ç§»äº†ï¼ˆä¹Ÿå°±æ˜¯ç§»å‹•äº†å€¼ï¼‰ã€‚</p>
</blockquote>
<pre><code class="language-rust">let tuple: (u32, String) = (5, String::from(&quot;five&quot;));

// Here, tuple is moved, because the String moved:
let (x, _s) = tuple;

// The next line would give &quot;error: use of partially moved value: `tuple`&quot;
// println!(&quot;Tuple is: {:?}&quot;, tuple);

// However,

let tuple = (5, String::from(&quot;five&quot;));

// Here, tuple is _not_ moved, as the String was never moved, and u32 is Copy:
let (x, _) = tuple;

// That means this works:
println!(&quot;Tuple is: {:?}&quot;, tuple);
</code></pre>
<p>é€™ä¹Ÿä»£è¡¨ä»»ä½•æš«æ™‚çš„è®Šæ•¸æœƒåœ¨é™³è¿°å¼çµæŸä¹‹å¾Œè¢«ä¸Ÿæ£„ï¼š</p>
<pre><code class="language-rust">// Here, the String created will be dropped immediately, as itâ€™s not bound:

let _ = String::from(&quot;  hello  &quot;).trim();
</code></pre>
<p>ä½ ä¹Ÿå¯ä»¥åœ¨æ¨¡å¼ä¸­ä½¿ç”¨ <code>..</code> å»å¿½ç•¥å¤šå€‹å€¼ï¼š</p>
<pre><code class="language-rust">enum OptionalTuple {
    Value(i32, i32, i32),
    Missing,
}

let x = OptionalTuple::Value(5, -2, 3);

match x {
    OptionalTuple::Value(..) =&gt; println!(&quot;Got a tuple!&quot;),
    OptionalTuple::Missing =&gt; println!(&quot;No such luck.&quot;),
}
</code></pre>
<p>é€™æœƒå°å‡º <code>Got a tuple!</code>ã€‚</p>
<h2>ref èˆ‡ ref mut</h2>
<p>å¦‚æœä½ æƒ³è¦ç²å¾—ä¸€å€‹<a href="references-and-borrowing.html">åƒç…§</a> (reference)ï¼Œå¯ä»¥ä½¿ç”¨ <code>ref</code> é—œéµå­—ï¼š</p>
<pre><code class="language-rust">let x = 5;

match x {
    ref r =&gt; println!(&quot;Got a reference to {}&quot;, r),
}
</code></pre>
<p>é€™æœƒå°å‡º <code>Got a reference to 5</code>ã€‚</p>
<p>é€™é‚Š <code>match</code> ä¸­çš„ <code>r</code> æ˜¯ä¸€å€‹ <code>&amp;i32</code> å‹åˆ¥ã€‚
æ›å¥è©±èªªï¼Œ<code>ref</code> é—œéµå­— <em>å»ºç«‹</em> äº†ä¸€å€‹å¯åœ¨æ¨¡å¼ç•¶ä¸­ä½¿ç”¨çš„åƒç…§ã€‚
å¦‚æœä½ éœ€è¦ä¸€å€‹å¯è®Šçš„ (mutable) åƒç…§ï¼Œå¯ä»¥ä½¿ç”¨ <code>ref mut</code>ï¼š</p>
<pre><code class="language-rust">let mut x = 5;

match x {
    ref mut mr =&gt; println!(&quot;Got a mutable reference to {}&quot;, mr),
}
</code></pre>
<h2>ç¯„åœ</h2>
<p>ä½ å¯ä»¥ç”¨ <code>...</code> é…å°ä¸€å€‹ç¯„åœçš„å€¼ï¼š</p>
<pre><code class="language-rust">let x = 1;

match x {
    1 ... 5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
</code></pre>
<p>é€™æœƒå°å‡º <code>one through five</code>ã€‚</p>
<p>ç¯„åœé€šå¸¸ç”¨åœ¨æ•´æ•¸å’Œ <code>char</code> ä¸Šï¼š</p>
<pre><code class="language-rust">let x = 'ğŸ’…';

match x {
    'a' ... 'j' =&gt; println!(&quot;early letter&quot;),
    'k' ... 'z' =&gt; println!(&quot;late letter&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
</code></pre>
<p>é€™æœƒå°å‡º <code>something else</code>ã€‚</p>
<h2>ç¶å®š</h2>
<p>ä½ å¯ä»¥ä½¿ç”¨ <code>@</code> æŠŠå€¼ç¶å®šåœ¨å‘½åä¸Šï¼š</p>
<pre><code class="language-rust">let x = 1;

match x {
    e @ 1 ... 5 =&gt; println!(&quot;got a range element {}&quot;, e),
    _ =&gt; println!(&quot;anything&quot;),
}
</code></pre>
<p>é€™æœƒå°å‡º <code>got a range element 1</code>ã€‚
ç•¶ä½ æƒ³å°è³‡æ–™çµæ§‹ä¸­çš„éƒ¨åˆ†é€²è¡Œè¤‡é›œçš„é…å°æ™‚ï¼Œé€™ååˆ†æœ‰ç”¨ï¼š</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Person {
    name: Option&lt;String&gt;,
}

let name = &quot;Steve&quot;.to_string();
let x: Option&lt;Person&gt; = Some(Person { name: Some(name) });
match x {
    Some(Person { name: ref a @ Some(_), .. }) =&gt; println!(&quot;{:?}&quot;, a),
    _ =&gt; {}
}
</code></pre>
<p>é€™æœƒå°å‡º <code>Some(&quot;Steve&quot;)</code>ï¼šå› ç‚ºæˆ‘å€‘æŠŠå…§éƒ¨çš„ <code>name</code> ç¶å®šåˆ° <code>a</code> äº†ã€‚</p>
<p>å¦‚æœä½ å°‡ <code>@</code> èˆ‡ <code>|</code> ä¸€èµ·ä½¿ç”¨ï¼Œä½ éœ€è¦ç¢ºä¿åœ¨æ¨¡å¼çš„æ¯ä¸€éƒ¨ä»½éƒ½æœ‰ç¶å®šå‘½åï¼š</p>
<pre><code class="language-rust">let x = 5;

match x {
    e @ 1 ... 5 | e @ 8 ... 10 =&gt; println!(&quot;got a range element {}&quot;, e),
    _ =&gt; println!(&quot;anything&quot;),
}
</code></pre>
<h2>å®ˆè¡› (Guards)</h2>
<p>ä½ å¯ä»¥ä½¿ç”¨ <code>if</code> ä¾†ç”¢ç”Ÿ &quot;é…å°å®ˆè¡›&quot; (match guards)ï¼š</p>
<pre><code class="language-rust">enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(i) if i &gt; 5 =&gt; println!(&quot;Got an int bigger than five!&quot;),
    OptionalInt::Value(..) =&gt; println!(&quot;Got an int!&quot;),
    OptionalInt::Missing =&gt; println!(&quot;No such luck.&quot;),
}
</code></pre>
<p>é€™æœƒå°å‡º <code>Got an int!</code>ã€‚</p>
<p>å¦‚æœä½ åœ¨å¤šé‡æ¨¡å¼ä¸­ä½¿ç”¨ <code>if</code>ï¼Œé‚£ <code>if</code> å°‡æœƒå¥—ç”¨åœ¨å¤šé‡æ¨¡å¼çš„æ‰€æœ‰æ¨¡å¼ä¸Šï¼š</p>
<pre><code class="language-rust">let x = 4;
let y = false;

match x {
    4 | 5 if y =&gt; println!(&quot;yes&quot;),
    _ =&gt; println!(&quot;no&quot;),
}
</code></pre>
<p>é€™æœƒå°å‡º <code>no</code>ï¼Œå› ç‚º <code>if</code> å¥—ç”¨åœ¨æ•´å€‹ <code>4 | 5</code> ä¹‹ä¸Šï¼Œè€Œä¸åªæ˜¯ <code>5</code>ã€‚
æ›å¥è©±èªªï¼Œ<code>if</code> è¡Œç‚ºçš„å„ªå…ˆæ¬Šå°±åƒæ˜¯ï¼š</p>
<pre><code class="language-text">(4 | 5) if y =&gt; ...
</code></pre>
<p>è€Œä¸æ˜¯ï¼š</p>
<pre><code class="language-text">4 | (5 if y) =&gt; ...
</code></pre>
<h2>æ··åˆèˆ‡é…å° (Mix and Match)</h2>
<p>æ©ï¼æœ‰éå¸¸å¤šç¨®æ–¹æ³•å¯ä»¥é€²è¡Œé…å°ï¼Œè€Œä¸”å®ƒå€‘å¯ä»¥æ ¹æ“šä½ æƒ³åšçš„äº‹æƒ…è€Œçµ„åˆä½¿ç”¨ï¼š</p>
<pre><code class="language-rust,ignore">match x {
    Foo { x: Some(ref name), y: None } =&gt; ...
}
</code></pre>
<p>æ¨¡å¼éå¸¸å¼·å¤§ã€‚
å¥½å¥½å–„ç”¨å®ƒå€‘ã€‚</p>
<blockquote>
<p><em>commit b49ce1a</em></p>
</blockquote>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="match.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="method-syntax.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="match.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="method-syntax.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
